"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[8855],{56778:(e,n,t)=>{t.d(n,{A:()=>r});t(96540);var i=t(18215);const a={tabItem:"tabItem_Ymn6"};var s=t(74848);function r(e){let{children:n,hidden:t,className:r}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,i.A)(a.tabItem,r),hidden:t,children:n})}},37244:(e,n,t)=>{t.d(n,{A:()=>v});var i=t(96540),a=t(18215),s=t(44319),r=t(56347),l=t(94280),o=t(73024),d=t(58417),c=t(44031);function h(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:a}}=e;return{value:n,label:t,attributes:i,default:a}}))}(t);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o.aZ)(s),(0,i.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(a.location.search);n.set(s,e),a.replace({...a.location,search:n.toString()})}),[s,a])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,s=u(e),[r,o]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=t.find((e=>e.default))??t[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:s}))),[d,h]=m({queryString:t,groupId:a}),[x,j]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,s]=(0,c.Dv)(t);return[a,(0,i.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:a}),g=(()=>{const e=d??x;return p({value:e,tabValues:s})?e:null})();(0,l.A)((()=>{g&&o(g)}),[g]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),h(e),j(e)}),[h,j,s]),tabValues:s}}var j=t(46916);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function f(e){let{className:n,block:t,selectedValue:i,selectValue:r,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.a_)(),c=e=>{const n=e.currentTarget,t=o.indexOf(n),a=l[t].value;a!==i&&(d(n),r(a))},h=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>o.push(e),onKeyDown:h,onClick:c,...s,className:(0,a.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":i===n}),children:t??n},n)}))})}function I(e){let{lazy:n,children:t,selectedValue:s}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===s));return e?(0,i.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function y(e){const n=x(e);return(0,b.jsxs)("div",{className:(0,a.A)("tabs-container",g.tabList),children:[(0,b.jsx)(f,{...n,...e}),(0,b.jsx)(I,{...n,...e})]})}function v(e){const n=(0,j.A)();return(0,b.jsx)(y,{...e,children:h(e.children)},String(n))}},58226:(e,n,t)=>{t.d(n,{a:()=>x});var i=t(96540),a=t(72774),s=t(63051),r=t(28968),l=t(48875),o=t(44676),d=t(47859),c=t(4671),h=t(99343),u=t(7324),p=t(39781),m=t(74848);const x=(0,i.memo)((e=>{let{open:n,fullScreen:t=!1,title:l,maxWidth:x="md",onClose:g,children:b}=e;const[f,I]=(0,i.useState)(t),y=(0,i.useCallback)((()=>{I((e=>!e))}),[]);return(0,m.jsxs)(s.A,{open:n,onClose:g,fullScreen:f,TransitionComponent:j,maxWidth:x,children:[(0,m.jsx)(a.A,{sx:{position:"relative"},children:(0,m.jsxs)(o.A,{children:[(0,m.jsx)(d.A,{sx:{ml:2,flex:1},variant:"h6",component:"div",children:l}),(0,m.jsx)(c.A,{onClick:y,style:{color:"white"},children:f?(0,m.jsx)(u.A,{}):(0,m.jsx)(h.A,{})}),(0,m.jsx)(c.A,{"aria-label":"close",onClick:g,style:{color:"white"},children:(0,m.jsx)(p.A,{})})]})}),(0,m.jsx)(r.A,{children:b})]})})),j=i.forwardRef((function(e,n){return(0,m.jsx)(l.A,{direction:"up",ref:n,...e})}))},47389:(e,n,t)=>{t.d(n,{l:()=>l});var i=t(96540),a=t(67512),s=t(58226),r=t(74848);const l=(0,i.memo)((e=>{let{buttonText:n,fullScreen:t=!1,title:l=n,variant:o="outlined",large:d=!1,maxWidth:c,useOriginalText:h=!0,children:u}=e;const[p,m]=(0,i.useState)(!1),x=(0,i.useCallback)((e=>{m(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),j=(0,i.useCallback)((()=>{m(!1)}),[]),g=h?{textTransform:"none"}:{};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.A,{"data-is-view-more-button":"true",onClick:x,variant:o,size:d?"large":"small",style:g,children:n}),(0,r.jsx)(s.a,{open:p,onClose:j,title:l,maxWidth:c,fullScreen:t,children:u})]})}))},38351:(e,n,t)=>{t.d(n,{Ay:()=>d,RM:()=>l});var i=t(74848),a=t(28453),s=t(37244),r=t(56778);const l=[];function o(e){const n={admonition:"admonition",code:"code",em:"em",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Initially, people used business fields directly as the primary key of tables. This is the most straightforward and easy to use approach, but it has the following problems:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Unstable primary key"}),"\n",(0,i.jsx)(n.p,{children:"Since the primary key itself is a business field, it can be modified, which leads to an unstable primary key."}),"\n",(0,i.jsxs)(n.p,{children:["Although the foreign keys that reference it in the database can use ",(0,i.jsx)(n.code,{children:"on update cascade"})," to keep consistency,\nan unstable primary key will cause many problems for systems outside the database, such as caches."]}),"\n",(0,i.jsx)(n.p,{children:"Even if a unified solution to the primary key instability problem can be abstracted at the technical level, it is not recommended, because it makes the system difficult to understand."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"High cost of multi-table joins"}),"\n",(0,i.jsx)(n.p,{children:"Since the primary key itself is a business field, its type is likely to be a relatively long string type rather than a numeric type,\nand it may even be a composite primary key composed of multiple columns, which leads to high cost of multi-table joins."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"To solve the above problems, people learned to use data without business meaning as the primary key, such as"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Auto numbering by database"}),"\n",(0,i.jsx)(n.li,{children:"Sequence value by database"}),"\n",(0,i.jsx)(n.li,{children:"UUID"}),"\n",(0,i.jsx)(n.li,{children:"Snowflake ID"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"To enable idempotent saves for save commands, Jimmer introduces two concepts: Id and Key"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"@Id: Primary key"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"@Key: Business primary key"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If Id itself is a business attribute (not recommended), no need to specify Key, because Id itself already represents the uniqueness constraint at the business level."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If Id has no business meaning (recommended), then Key represents what the uniqueness constraint is at the business level."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"See the following example:"}),"\n",(0,i.jsxs)(s.A,{groupId:"language",children:[(0,i.jsx)(r.A,{value:"java",label:"Java",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Entity  \npublic interface TreeNode {\n\n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    // highlight-next-line\n    @Key\n    String name();\n\n    // highlight-next-line \n    @Key  \n    @ManyToOne\n    @Nullable\n    TreeNode parent();\n\n    @OneToMany(mappedBy = "parent")\n    List<TreeNode> childNodes();\n}\n'})})}),(0,i.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'@Entity\ninterface TreeNode {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY) \n    val id: Long\n\n    // highlight-next-line\n    @Key\n    val name: String\n\n    // highlight-next-line\n    @Key   \n    @ManyToOne\n    val parent: TreeNode?\n\n    @OneToMany(mappedBy = "parent")\n    val childNodes: List<TreeNode>\n}\n'})})})]}),"\n",(0,i.jsxs)(n.p,{children:["Here, the Id of the ",(0,i.jsx)(n.code,{children:"TreeNode"})," entity uses auto numbering and has no business meaning. Therefore, to better match save commands,\n",(0,i.jsx)(n.code,{children:"key"})," is specified here, consisting of two properties: ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"parent"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The corresponding DDL is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"create table TREE_NODE(\n    ID bigint not null,\n    NAME varchar(20) not null,\n    PARENT_ID bigint\n);\n\nalter table TREE_NODE\n    add constraint PK_TREE_NODE\n        primary key(ID);\n        \nalter table TREE_NODE\n    add constraint UQ_TREE_NODE\n        /* highlight-next-line */\n        unique(NAME, PARENT_ID); \n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"parent"})," properties of the entity type decorated with @Key correspond to the UNIQUE constraint ",(0,i.jsx)(n.em,{children:"(or UNIQUE INDEX)"})," composed of the ",(0,i.jsx)(n.code,{children:"NAME"})," and ",(0,i.jsx)(n.code,{children:"PARENT_ID"})," columns in the database."]}),"\n",(0,i.jsx)(n.p,{children:"This uniqueness constraint can be analogized to file systems. File systems allow directories or files with the same name, but do not allow the same name if the parent directory is specified."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"Through this example, we see:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Key can consist of multiple properties"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Foreign keys can be part of Key"}),"\n"]}),"\n"]})]}),"\n",(0,i.jsx)(n.p,{children:"Let's take another look at another example where the properties that make up Key are all properties based on foreign keys:"}),"\n",(0,i.jsxs)(s.A,{groupId:"language",children:[(0,i.jsx)(r.A,{value:"java",label:"Java",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Entity\npublic interface OrderItem {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    long id();\n\n    // highlight-next-line\n    @Key   \n    @ManyToOne\n    Order order();\n\n    // highlight-next-line\n    @Key\n    @ManyToOne\n    Product product();\n\n    int quantity();\n\n    // Snapshot of `product.price`\n    BigDecimal unitPrice(); \n}\n"})})}),(0,i.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Entity\ninterface OrderItem {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    // highlight-next-line\n    @Key\n    @ManyToOne\n    val order: Order\n\n    // highlight-next-line\n    @Key \n    @ManyToOne\n    val product: Product\n\n    val quantity: Int\n\n    // Snapshot of `product.price`\n    val unitPrice: BigDecimal\n}\n"})})})]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},34097:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"mutation/save-command/save-mode","title":"Save Mode of Aggregate-Root","description":"Save Modes","source":"@site/docs/mutation/save-command/save-mode.mdx","sourceDirName":"mutation/save-command","slug":"/mutation/save-command/save-mode","permalink":"/jimmer-doc/docs/mutation/save-command/save-mode","draft":false,"unlisted":false,"editUrl":"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/mutation/save-command/save-mode.mdx","tags":[],"version":"current","lastUpdatedAt":1731875555000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Save Mode of Aggregate-Root"},"sidebar":"tutorialSidebar","previous":{"title":"Data Classification","permalink":"/jimmer-doc/docs/mutation/save-command/data-classification"},"next":{"title":"Save Mode of Associated Objects","permalink":"/jimmer-doc/docs/mutation/save-command/associated-save-mode"}}');var a=t(74848),s=t(28453),r=t(37244),l=t(56778);t(38351),t(47389);const o={sidebar_position:3,title:"Save Mode of Aggregate-Root"},d=void 0,c={},h=[{value:"Save Modes",id:"save-modes",level:2},{value:"INSERT_ONLY",id:"insert_only",level:2},{value:"UPDATE_ONLY",id:"update_only",level:2},{value:"Updating Data by ID",id:"updating-data-by-id",level:3},{value:"Updating Data by Key",id:"updating-data-by-key",level:3},{value:"UPSERT",id:"upsert",level:2},{value:"Determining Data Existence by Id",id:"determining-data-existence-by-id",level:3},{value:"Determining Data Existence by Key",id:"determining-data-existence-by-key",level:3},{value:"Improved Key-based Determination",id:"improved-key-based-determination",level:3},{value:"INSERT_IF_ABSENT",id:"insert_if_absent",level:2},{value:"NON_IDEMPOTENT_UPSERT",id:"non_idempotent_upsert",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"save-modes",children:"Save Modes"}),"\n",(0,a.jsx)(n.p,{children:"The save command supports 5 save modes that control how the aggregate root itself is saved:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"UPSERT: This is the default mode. It first queries to check if the aggregate root object being saved exists:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If it doesn't exist: Executes an INSERT statement"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If it exists: Executes an UPDATE statement"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"INSERT_ONLY: Unconditionally executes an INSERT statement"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"INSERT_IF_ABSENT:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If the data already exists, ignores the operation"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Otherwise, inserts the data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"UPDATE_ONLY: Unconditionally executes an UPDATE statement"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"NON_IDEMPOTENT_UPSERT:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If the object's @Id property or @Key properties are specified, performs behavior equivalent to UPSERT"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Otherwise, performs an INSERT operation"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This behavior is equivalent to JPA's ",(0,a.jsx)(n.code,{children:"merge"})," or Hibernate's ",(0,a.jsx)(n.code,{children:"saveOrUpdate"}),", but it is not recommended in Jimmer."]})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.admonition,{type:"caution",children:[(0,a.jsx)(n.p,{children:"Save modes only affect the aggregate root object, not other associated objects."}),(0,a.jsxs)(n.p,{children:["For associated objects, please refer to ",(0,a.jsx)(n.a,{href:"./associated-save-mode",children:"Associated Object Save Mode"}),"."]})]}),"\n",(0,a.jsx)(n.h2,{id:"insert_only",children:"INSERT_ONLY"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"INSERT_ONLY"})," means unconditionally inserting data"]}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setName("SQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\n\nList<Long> allocatedIds = sqlClient    \n    .saveEntities(\n        books, \n        // highlight-next-line\n        SaveMode.INSERT_ONLY\n    )\n    .getItems()\n    .stream()\n    .map(item -> item.getModifiedEntity().id())\n    .collect(Collectors.toList());\n\nSystem.out.println("Allocated ids: " + allocatedIds);\n'})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val books = listOf(\n    Book {\n        name = "SQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\n\nval allocatedIds = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.INSERT_ONLY\n    )\n    .items\n    .map {\n        it.modifiedEntity.id\n    }\n\nprintln("Allocated ids: $allocatedIds")\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"INSERT_ONLY works very simply - it inserts unconditionally without any checks."}),"\n",(0,a.jsx)(n.p,{children:"The generated batch operation SQL is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"insert into BOOK(NAME, EDITION, PRICE, STORE_ID) values(?, ?, ?, ?)\n/* batch-0: SQL in Action, 3, 49.9, 2 */\n/* batch-1: [LINQ in Action, 2, 39.9, 2 */\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this example, since the id property's corresponding column uses database auto-numbering, after the batch insertion is complete, the ids allocated by the database for all data will be returned. The print result will be:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Allocated ids: [100, 101]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"update_only",children:"UPDATE_ONLY"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"UPDATE_ONLY"})," means unconditionally updating data, and it has two scenarios:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For Id-Specified objects, modify data according to id"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For Key-Specified objects, modify data according to key"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"updating-data-by-id",children:"Updating Data by ID"}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setId(3L); // Matched\n        draft.setName("SQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setId(100L); // Not matched\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nBatchSaveResult<Book> result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    );\nSystem.out.println("Affected row count: " + result.getTotalAffectedRowCount());\n'})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val books = listOf(\n    Book {\n        id = 3L\n        name = "SQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        id = 100L\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    )\n\nprintln("Affected row count: ${result.totalAffectedRowCount}")\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"Since the object's id property is specified, the object is updated based on its id. The generated batch operation SQL is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"update BOOK\nset\n    NAME = ?,\n    EDITION = ?,\n    PRICE = ?,\n    STORE_ID = ?\nwhere\n    ID = ?\n/* batch-0: [SQL in Action, 3, 49.9, 2, 3] *\n/* batch-1: [LINQ in Action, 2, 39.9, 2, 100] */\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This batch operation attempts to modify two records. Assuming the database only has one matching record, the print result will be ",(0,a.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"updating-data-by-key",children:"Updating Data by Key"}),"\n",(0,a.jsx)(n.p,{children:"Assume the Book entity is defined as follows:"}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="Book.java"',children:"@Entity\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    // highlight-next-line\n    @Key\n    String name();\n\n    // highlight-next-line\n    @Key\n    int edition();\n\n    ...other properties that are neither id nor key omitted...\n}\n"})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",metastring:'title="Book.kt"',children:"@Entity\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    // highlight-next-line\n    @Key\n    val name: String\n\n    // highlight-next-line\n    @Key\n    val edition: Int\n\n    ...other properties that are neither id nor key omitted...\n}\n"})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Here ",(0,a.jsx)(n.code,{children:"Book.name"})," and ",(0,a.jsx)(n.code,{children:"Book.edition"})," are annotated with ",(0,a.jsx)(n.a,{href:"../../mapping/advanced/key",children:"@Key"}),"."]}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        // Id is not specified\n        draft.setName("Learning GraphQL");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        // Id is not specified\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nBatchSaveResult<Book> result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    );\nfor (MutationResultItem<Book> item : result.getItems()) {\n    if (ImmutableObjects.isLoaded(item.getModifiedEntity(), BookProps.ID)) {\n        System.out.println("Data is updated, updated id is " + item.getModifiedEntity().id());\n    } else {\n        System.out.println("Data is not updated");\n    }\n}\n'})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val books = listOf(\n    Book {\n        // Id is not specified\n        name = "Learning GraphQL"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        // Id is not specified\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    )\nfor (item in result.item) {\n    if (isLoaded(item.modifiedEntity, Book::id)) {\n        println("Data is updated, updated id is ${item.isModified}")\n    } else {\n        println("Data is not updated")\n    }\n}\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"Since the object's id property is not specified, the object is updated based on its key. The generated batch operation SQL is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"update BOOK\nset\n    PRICE = ?,\n    STORE_ID = ?\nwhere\n    NAME = ?\n    and\n    EDITION = ?\n/* batch-0: [49.9, 2, Learning GraphQL, 3] */\n/* batch-1: [39.9, 2, LINQ in Action, 2] */\n"})}),"\n",(0,a.jsx)(n.p,{children:"The print result will be:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Data is updated, updated id is 3\nData is not updated\n"})}),"\n",(0,a.jsx)(n.h2,{id:"upsert",children:"UPSERT"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"UPSERT"})," means first checking if the data exists - if it exists then update it, otherwise insert it"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For Id-Specified objects, existence is determined by id, then deciding between INSERT or UPDATE"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For Key-Specified objects, existence is determined by key, then deciding between INSERT or UPDATE"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"determining-data-existence-by-id",children:"Determining Data Existence by Id"}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setId(3L);\n        draft.setName("Learning GraphQL");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setId(90L);\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\n\nsqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPSERT\n    );\n'})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val books = listOf(\n    Book {\n        id = 3L\n        name = "Learning GraphQL"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        id = 90L\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nsqlClient.save(\n    books,\n    // highlight-next-line\n    SaveMode.UPSERT\n)\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"Jimmer prioritizes using the database's native UPSERT capabilities, so it generates different SQL for different databases"}),"\n",(0,a.jsxs)("table",{children:[(0,a.jsx)("thead",{children:(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{children:"Database"}),(0,a.jsx)("th",{children:"Generated SQL"})]})}),(0,a.jsxs)("tbody",{children:[(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"H2"}),(0,a.jsx)("td",{children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"merge into BOOK(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) key(ID) values(\n    ?, ?, ?, ?, ?\n)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"MySQL"}),(0,a.jsx)("td",{children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"insert into BOOK(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?, ?)\non duplicate key update \n    NAME = values(NAME), \n    EDITION = values(EDITION), \n    PRICE = values(PRICE), \n    STORE_ID = values(STORE_ID)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Postgres"}),(0,a.jsx)("td",{children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"insert into BOOK(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?, ?)\non conflict(ID) do update set\n    NAME = excluded.NAME, \n    EDITION = excluded.EDITION, \n    PRICE = excluded.PRICE, \n    STORE_ID = excluded.STORE_ID)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */\n"})})})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"determining-data-existence-by-key",children:"Determining Data Existence by Key"}),"\n",(0,a.jsx)(n.p,{children:"If the object's id is not specified, for example:"}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setName("Learning GraphQL");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("GraphQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("Kotlin in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nList<Long> ids = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPSERT\n    )\n    .getItems()\n    .stream().map(it -> it.getModifiedEntity().id())\n    .collect(Collectors.toList());\nSystem.out.println(ids);\n'})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val books = listOf(\n    Book {\n        name = "Learning GraphQL"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "GraphQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    },\n    Book {\n        name = "Kotlin in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval ids = sqlClient.save(\n    books,\n    // highlight-next-line\n    SaveMode.UPSERT\n).items.map{ it.id }\nprintln(ids)\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"By default, Jimmer tries to use the database's native UPSERT capabilities whenever possible."}),"\n",(0,a.jsxs)(n.p,{children:["However, in this case, it cannot achieve this ",(0,a.jsx)(n.em,{children:"(we'll discuss how to solve this issue shortly)"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"In this situation, Jimmer will first execute a query, then based on the query results, determine which data should be INSERTed and which should be UPDATEd. This results in three SQL statements:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Query, with reason provided"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* highlight-next-line */\nPurpose: COMMAND(KEY_UNIQUE_CONSTRAINT_REQUIRED)\nSQL: select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION\nfrom BOOK tb_1_\nwhere\n    (tb_1_.NAME, tb_1_.EDITION) in (\n        (? /* Learning GraphQL */, ? /* 3 */), \n        (? /* GraphQL in Action */, ? /* 3 */), \n        (? /* LINQ in Action */, ? /* 2 */), \n        (? /* Kotlin in Action */, ? /* 2 */)\n    )\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["Jimmer prints ",(0,a.jsx)(n.code,{children:"KEY_UNIQUE_CONSTRAINT_REQUIRED"})," in the logs, which is called QueryReason."]}),(0,a.jsx)(n.p,{children:"Jimmer prioritizes using the database's native UPSERT capabilities, and if it cannot do so resulting in a query, it provides the QueryReason to help users investigate and find solutions."})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"INSERT operation for non-existing data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"insert into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) values(\n    ?, ?, ?, ?\n)\n/* batch-0: [LINQ in Action, 2, 39.9, 2] */\n/* batch-1: [Kotlin in Action, 2, 39.9, 2] */\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"UPDATE operation for existing data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"update BOOK\nset\n    PRICE = ?,\n    STORE_ID = ?\nwhere\n    ID = ?\n/* batch-0: [49.9, 2, 3] */\n/* batch-1: [49.9, 2, 12] */\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The printed result is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"[3, 12, 100, 101]\n"})}),"\n",(0,a.jsx)(n.p,{children:"Where:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"3 and 12 represent the ids of updated data"}),"\n",(0,a.jsx)(n.li,{children:"100 and 101 represent new ids assigned by the database for inserted data"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"improved-key-based-determination",children:"Improved Key-based Determination"}),"\n",(0,a.jsxs)(n.p,{children:["In the previous example, Jimmer executed a query and provided the QueryReason ",(0,a.jsx)(n.code,{children:"KEY_UNIQUE_CONSTRAINT_REQUIRED"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Jimmer provides detailed documentation comments for all QueryReasons, see ",(0,a.jsx)(n.a,{href:"https://github.com/babyfish-ct/jimmer/blob/main/project/jimmer-sql/src/main/java/org/babyfish/jimmer/sql/ast/mutation/QueryReason.java",children:"QueryReason"})," for details."]}),"\n",(0,a.jsxs)(n.p,{children:["For ",(0,a.jsx)(n.code,{children:"KEY_UNIQUE_CONSTRAINT_REQUIRED"})," specifically, it indicates the need for:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Creating a unique constraint for ",(0,a.jsx)(n.code,{children:"Book.name"})," and ",(0,a.jsx)(n.code,{children:"Book.edition"})," properties:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"alter table book\n    add constraint uq_book__name_edition\n        /* highlight-next-line */\n        unique(name, edition);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This is because the database's UPSERT functionality depends on unique constraints ",(0,a.jsx)(n.em,{children:"(or unique indexes)"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Informing Jimmer through the ",(0,a.jsx)(n.code,{children:"@KeyUniqueConstraint"})," annotation that the properties modified by ",(0,a.jsx)(n.code,{children:"@Key"})," have corresponding unique constraints ",(0,a.jsx)(n.em,{children:"(or unique indexes)"})," in the database"]}),"\n",(0,a.jsxs)(r.A,{groupId:"language",children:[(0,a.jsx)(l.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="Book.java"',children:"@Entity\n// highlight-next-line\n@KeyUniqueConstraint\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    @Key\n    String name();\n\n    @Key\n    int edition();\n\n    ...omitting other properties that are neither id nor key...\n}\n"})})}),(0,a.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",metastring:'title="Book.kt"',children:"@Entity\n// highlight-next-line\n@KeyUniqueConstraint\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    @Key\n    val name: String\n\n    @Key\n    val edition: Int\n\n    ...omitting other properties that are neither id nor key...\n}\n"})})})]}),"\n",(0,a.jsxs)(n.admonition,{type:"caution",children:[(0,a.jsx)(n.p,{children:"For MySQL, you need:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@KeyUniqueConstraint(noMoreUniqueConstraints = true)\n"})})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Once these two improvements are made, when running the previous example again, Jimmer will no longer execute a select statement but instead directly utilize the database's native UPSERT capabilities"}),"\n",(0,a.jsxs)("table",{children:[(0,a.jsx)("thead",{children:(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{children:"Database"}),(0,a.jsx)("th",{children:"Generated SQL"})]})}),(0,a.jsxs)("tbody",{children:[(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"H2"}),(0,a.jsx)("td",{children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"merge into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) key(\n    /* highlight-next-line */\n    NAME, EDITION\n) values(\n    ?, ?, ?, ?\n)\n/* batch-0: [Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [GraphQL in Action, 3, 49.9, 2] */\n/* batch-2: [LINQ in Action, 2, 39.9, 2] */\n/* batch-3: [Kotlin in Action, 2, 39.9, 2] */\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"MySQL"}),(0,a.jsx)("td",{children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"insert into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?)\non duplicate key update \n    /* fake update to return all ids */ ID = last_insert_id(ID), \n    NAME = values(NAME), \n    EDITION = values(EDITION), \n    PRICE = values(PRICE), \n    STORE_ID = values(STORE_ID)\n/* batch-0: [Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [GraphQL in Action, 3, 49.9, 2] */\n/* batch-2: [LINQ in Action, 2, 39.9, 2] */\n/* batch-3: [Kotlin in Action, 2, 39.9, 2] */\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Postgres"}),(0,a.jsx)("td",{children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"insert into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?, ?)\non conflict(\n    /* highlight-next-line */\n    NAME, EDITION\n) do update set\n    NAME = excluded.NAME, \n    EDITION = excluded.EDITION, \n    PRICE = excluded.PRICE, \n    STORE_ID = excluded.STORE_ID\nreturning ID\n/* batch-0: [Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [GraphQL in Action, 3, 49.9, 2] */\n/* batch-2: [LINQ in Action, 2, 39.9, 2] */\n/* batch-3: [Kotlin in Action, 2, 39.9, 2] */\n"})})})]})]})]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"If you are using MySQL, there are two points to note:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Unlike Postgres which can explicitly specify columns used for determining data existence through ",(0,a.jsx)(n.code,{children:"on conflict(NAME, EDITION)"}),",\nMySQL is special in that its ",(0,a.jsx)(n.code,{children:"on duplicate key"})," cannot explicitly specify which columns are used for determining data existence."]}),"\n",(0,a.jsxs)(n.p,{children:["Therefore, when an ",(0,a.jsx)(n.code,{children:"insert ... on duplicate key"})," statement doesn't insert the id field, MySQL will determine data existence based on all fields participating in unique constraints, even if these fields belong to multiple different unique constraints."]}),"\n",(0,a.jsxs)(n.p,{children:["Thus, you must add an additional parameter ",(0,a.jsx)(n.code,{children:"noMoreUniqueConstraints"})," to the annotation, like:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@KeyUniqueConstraint(noMoreUniqueConstraints = true)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"noMoreUniqueConstraints = true"})," tells Jimmer that the table corresponding to the entity has only one unique constraint ",(0,a.jsx)(n.em,{children:"(or unique index)"}),".\nUsers need to be responsible for their commitment."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The SQL generated for MySQL includes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* fake update to return all ids */ ID = last_insert_id(ID)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is a relatively tricky technique. If the data is updated, it returns the existing id of the updated data; otherwise, it returns the id assigned by the database for automatically inserted data."}),"\n"]}),"\n"]})]}),"\n",(0,a.jsx)(n.p,{children:"Apart from utilizing the database's native UPSERT capabilities, the functionality is exactly the same as the previous example, and the printed result will not change at all, as shown below:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"[3, 12, 100, 101]\n"})}),"\n",(0,a.jsx)(n.p,{children:"Where:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"3 and 12 represent the ids of updated data"}),"\n",(0,a.jsx)(n.li,{children:"100 and 101 represent new ids assigned by the database for inserted data"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"insert_if_absent",children:"INSERT_IF_ABSENT"}),"\n",(0,a.jsx)(n.p,{children:"To be continued"}),"\n",(0,a.jsx)(n.h2,{id:"non_idempotent_upsert",children:"NON_IDEMPOTENT_UPSERT"}),"\n",(0,a.jsx)(n.p,{children:"To be continued"})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);